#! /usr/bin/env perl

=head1 NAME

xfile - add Xtra data (meta-data) to files

=head1 SYNOPSIS

    xfile --help | --manpage | --version
    xfile [--verbose] [--derive] --add I<string>=I<string> file [file ...]
    xfile [--verbose] --delete I<string> file [file ...]
    xfile [--verbose] --extract file [file ...]
    xfile [--verbose] --from_file I<otherfile> file [file ...]

=head1 DESCRIPTION

This adds Xtra data (meta-data) to files, using either Extended Attributes,
or the file's own meta-data (depending on the type of the file).

=head1 OPTIONS

=over

=item --add I<string>=I<string>

Set the given field.

=item --delete I<string>

Delete the given field.

=item --derive

Derive the needed value of the given field from other information.

=item --extract

Extract metadata in other formats (e.g. EXIF data) and save as extended attributes.

=item --from_file I<filename>

Extract metadata in other formats (e.g. EXIF data) from one file and save as extended attributes in another file.

=item --help

Display short help and exit.

=item --manpage

Display full documentation and exit.

=item --verbose

Make the output verbose.


=back

=cut
use common::sense;
use Getopt::Long;
use Getopt::ArgvFile qw(argvFile);
use Pod::Usage;
use File::Basename;
use File::Spec;
use YAML::Any;
use File::Sticker;

#========================================================
# Subroutines

sub process_args () {
    my $opts = {
        overwrite => 0,
    };

    # check the rc file
    my $nameBuilder=sub
    {
        my $bn = basename($_[0], '');
        [".${bn}rc", ".${bn}/config", ".config/${bn}/config"];
    };
    argvFile(
        startupFilename=>$nameBuilder,
        home=>1,
        current=>1);

    my $op = new Getopt::Long::Parser;
    $op->configure(qw(auto_version auto_help));
    $op->getoptions($opts,
	       'verbose+',
	       'manpage',
               'derive!',
               'extract!',
               'overwrite!',
               'from_file=s',
	       'add=s%',
	       'delete=s@',
	       'fields_wanted=s%',
	      ) or pod2usage(2);

    if ($opts->{manpage})
    {
	pod2usage({ -message => "$0 ",
		    -exitval => 0,
		    -verbose => 2,
	    });
    }

    # complain if there are no arguments
    pod2usage({ -message => "$0 Needs arguments!",
        -exitval => 2,
        -verbose => 0,
    }) unless @ARGV;

    return $opts;
} # process_args

sub print_meta {
    my $opts = shift;
    my %args = @_;

    my $sticker = $args{sticker};
    my $filename = $args{filename};

    my $meta = $sticker->read_meta($filename);

    say STDERR "== $filename ==";
    print STDERR Dump($meta);
} # print_meta

sub meta_from_file {
    my $opts = shift;
    my %args = @_;

    my $sticker = $args{sticker};
    my $filename = $args{filename};
    my $from_file = $args{from_file};

    my $meta = $sticker->read_meta($from_file);

    $sticker->replace_all_meta(filename=>$filename,meta=>$meta);
} # meta_from_file

#========================================================
# Main

MAIN: {
    my $opts = process_args();
    my $sticker = File::Sticker->new(
        fields_wanted=>$opts->{fields_wanted},
        overwrite=>$opts->{overwrite},
        derive=>$opts->{derive},
        verbose=>$opts->{verbose},
    );

    foreach my $filename (@ARGV)
    {
        if ($opts->{add} or $opts->{delete})
        {
            if ($opts->{add})
            {
                foreach my $fn (keys %{$opts->{add}})
                {
                    $sticker->add_field_to_file(
                        filename => $filename,
                        field => $fn,
                        value => $opts->{field}->{$fn});
                }
            }
            if ($opts->{delete})
            {
                foreach my $fn (@{$opts->{delete}})
                {
                    $sticker->delete_field_from_file(
                        filename => $filename,
                        field => $fn);
                }
            }
        }
        elsif ($opts->{extract})
        {
            meta_from_file($opts,sticker=>$sticker,filename=>$filename,from_file=>$filename);
            if ($opts->{verbose})
            {
                print_meta($opts,sticker=>$sticker,filename=>$filename);
            }
        }
        elsif ($opts->{from_file})
        {
            meta_from_file($opts,sticker=>$sticker,filename=>$filename,from_file=>$opts->{from_file});
            if ($opts->{verbose})
            {
                print_meta($opts,sticker=>$sticker,filename=>$filename);
            }
        }
        else # list
        {
            print_meta($opts,sticker=>$sticker,filename=>$filename);
        }
    } # for each file
}
